#!/bin/env perl
#
# Ex: bbBORead.pl -lookup US010201AA95 -keytype ID_ISIN -file fixedincome_bo_namr.out
# This helps search for the file, 
#  ls /auto/data/bloomberg/data_license/back_office/descriptive/*namr*20050727* |cut -d/ -f7 |cut -d. -f1 |sort -u
# Corp Action files are not <yet> handled since the format is not defined in the file
#     /auto/data/bloomberg/data_license/back_office/corpact/equity_euro.cax.20050728.gz
# Some dev files located under /datadev/edsrt/feed_loads/SecurityDescriptive/RawLoads/Bloomberg/data/
# Need an option to do everything for current date
# Need to be able to check multiple files- should be easy

use strict;
use warnings;
use Date::Manip qw(ParseDate UnixDate);

our ($verbose, $output_format, $listfiles, $filetype, $path, $file, $lookup, $date,
	$keytype, @fields, $back_office_dir, $back_office_dir2, $program, $display_by_position);

# Defaults
$program = $0;
$verbose = 0;
#$lookup = q{DMM5 };
#$lookup = q{P U3 Comdty};
#$lookup = q{DMM5 Comdty};
$lookup = q{CDM4 Cur};
#$date = UnixDate("last monday","%Y%m%d");
$date = UnixDate("yesterday","%Y%m%d");
$back_office_dir = q{/auto/data/bloomberg/data_license/back_office/};
$back_office_dir2 = q{/auto/factiva1/BloombergArchive/back_office/};
#$file = q{comdty_namr};
$file = q{equity_namr};
$filetype = q{descriptive};
$keytype = q{YellowKey};
$display_by_position = 1;
$output_format = 'XML';
@fields = ();

#my @ftypes = qw(corpact descriptive lookup notices pricing);
my %ftypes = (
    corpact	=> "cax",
    #descriptive	=> "dif", # or out
    descriptive	=> "out", # or out
    lookup	=> "out",
    notices	=> "doc",
    pricing	=> "px",
);

# really should try all with asia/asia1/asia2/euro/lamr/namr/none
my @comdty_filenames = qw^
comdty_asia
comdty_euro
comdty_lamr
comdty_namr
comdty_option_asia
comdty_option_euro
comdty_option_lamr
comdty_option_namr
^;

my @debt_filenames = qw^
corp_loan
corp_pfd_asia
corp_pfd_euro
corp_pfd_lamr
corp_pfd_namr
credit_risk
fixedincome_bo_namr
fixedincome_bulk_namr
fixedincome_bulk2_namr
fixedincome_ext_namr
fixedincome_bo_lamr
fixedincome_bulk_lamr
fixedincome_bulk2_lamr
fixedincome_ext_lamr
fixedincome_bo_euro
fixedincome_bulk_euro
fixedincome_bulk2_euro
fixedincome_ext_asia
fixedincome_bo_asia
fixedincome_bulk_asia
fixedincome_bulk2_asia
fixedincome_ext_asia
govt_agency_regl_asia
govt_agency_regl_asia_moody
govt_agency_regl_asia_sp
govt_agency_regl_euro
govt_agency_regl_euro_moody
govt_agency_regl_euro_sp
govt_agency_regl_lamr
govt_agency_regl_lamr_moody
govt_agency_regl_lamr_sp
govt_agency_regl_namr
govt_agency_regl_namr_moody
govt_agency_regl_namr_sp
govt_national_asia
govt_national_asia_moody
govt_national_asia_sp
govt_national_euro
govt_national_euro_moody
govt_national_euro_sp
govt_national_lamr
govt_national_lamr_moody
govt_national_lamr_sp
govt_national_namr
govt_national_namr_moody
govt_national_namr_sp
^;


my @curncy_filenames = qw^
curncy_asia1
curncy_asia2
curncy_euro
curncy_lamr
curncy_namr
^;

my @eqy_filenames = qw^
equity_asia1
equity_asia2
equity_euro
equity_lamr
equity_namr
equity_warrant_asia1
equity_warrant_asia2
equity_warrant_euro
equity_warrant_lamr
equity_warrant_namr
pfd_exch_asia
pfd_exch_lamr
pfd_exch_namr
pfd_exch_euro
^;

sub help
{
    print qq^
Usage: $program [-help][-verbose][-date <dt>][-file <file>][-lookup <name>][-keytype <fieldname>][-path <full path>]

Options:
    -help	This help
    -file	Identifies the unique file name component [$file]
    -filetype	Identifies the type name component (corpact,descriptive,lookup,notices,pricing)[$filetype] 
    -date	This is used as the file so that the actual file can be autogenerated [$date]
		Defaults to "yesterday". (Can use any string that can be passed to DateManip::UnixDate)
		Using the "file" name, the date, compression, and path to the back office files are added
    -listfiles	List all possible file names
    -lookup	Attribute value to look up. Will dump the entire file if not specified.
		If keytype == YellowKey (the default), the Yellow Key identifier is specified
		(Can be a regex -- make sure special characters are escaped from the shell and quoted if needed)
    -keytype	Attribute which determines what the lookup will match [$keytype]
		An ISIN is matched by specifying ID_ISIN.
		An CUSIP is matched by specifying ID_CUSIP.
		Default is the Yellow Key.
    -field	Only display this field, each field can be added with a separate statement [all]
    -outformat	Output Format [$output_format]
    -path	Do not autogenerate the file name components, use this as the full path.
    -bodir	Use path as base for the lookups [$back_office_dir]
    -display_by_name Display by sorted field name [default is by original field position]
    -verbose	Dumps some extra info. Multiple instances produce more info!

Example:
\% bbBORead.pl -keytype ID_ISIN -lookup XS0223460592 -file corp_pfd_euro
\% bbBORead.pl -date 20051128 -keytype ID_ISIN -lookup US1651678427 -verbose -verbose -filetype descriptive -file fixedincome_bo_namr -field EXCH_CODE

^;
    exit 0;
}

while ( my $arg = shift @ARGV ) {
    #print "Arg: $arg file: $file\n";
    help() if $arg =~ /^-help$/ || $arg =~ /^-h$/;
    $date = UnixDate(shift(@ARGV),"%Y%m%d") if $arg =~ /^-date$/ and ($#ARGV >= 0);
    $file = shift(@ARGV) if $arg =~ /^-file$/ and ($#ARGV >= 0);
    $path = shift(@ARGV) if $arg =~ /^-path$/ and ($#ARGV >= 0);
    $lookup = shift(@ARGV) if $arg =~ /^-lookup$/ and ($#ARGV >= 0);
    $keytype = shift(@ARGV) if $arg =~ /^-keytype$/ and ($#ARGV >= 0);
    $back_office_dir  = shift(@ARGV) if $arg =~ /^-bodir$/ and ($#ARGV >= 0);
    $filetype = shift(@ARGV) if $arg =~ /^-filetype$/ and ($#ARGV >= 0);
    $output_format = shift(@ARGV) if $arg =~ /^-outformat$/ and ($#ARGV >= 0);
    $listfiles = 1 if $arg =~ /^-listfiles$/;
    push @fields, shift(@ARGV) if $arg =~ /^-field$/ and ($#ARGV >= 0);
    $display_by_position = 0 if $arg =~ /^-display_by_name$/;
    ++$verbose if $arg =~ /^-verbose$/;
}

if ( $listfiles ) {

    foreach $file ( @comdty_filenames, @eqy_filenames, @curncy_filenames, @debt_filenames ) {
	if ( $filetype eq 'all' ) {
	    foreach my $ftype (keys %ftypes) {
		$path = $back_office_dir . $ftype . '/' . $file .'.'. $ftypes{$ftype} .'.'. $date;
		$path = $path . '.gz'
		    if not -e $path and -e $path . '.gz';
		print "$path\n"
		    if -e $path or $verbose > 1;
	    }
	} else {
	    $path = $back_office_dir . $filetype . '/' . $file .'.'. $ftypes{$filetype} .'.'. $date;
	    $path = $path . '.gz'
		if not -e $path and -e $path . '.gz';
	    print "$path\n"
		if -e $path or $verbose > 1;
	}
    }

} elsif ( $file eq "eqy" ) {

    foreach $file ( @eqy_filenames ) {
	$path = undef;
	process_file($file);
    }

} elsif ( $file eq "debt" ) {

    foreach $file ( @debt_filenames ) {
	$path = undef;
	process_file($file);
    }

} elsif ( $file eq "comdty" ) {

    foreach $file ( @comdty_filenames ) {
	$path = undef;
	process_file($file);
    }

} elsif ( $file eq "curncy" ) {

    foreach $file ( @curncy_filenames ) {
	$path = undef;
	process_file($file);
    }

} elsif ( $file eq "all" ) {

    foreach $file ( @comdty_filenames, @eqy_filenames, @curncy_filenames, @debt_filenames ) {
	$path = undef;
	process_file($file);
    }

} else {

    print "process_file($file)\n" if $verbose > 1;
    process_file($file);
}

sub process_file
{
    # Could use the Find::find functionality to wildcard files.
    my $file = shift;
    my @fieldnames;
    my $keyfield = -1;
    my $FType = $filetype;
    my $localpath = $path;

    unless ( $localpath ) {
	if ( $filetype eq 'all' ) {
	    foreach my $ftype (keys %ftypes) {
		$FType = $ftype;
		$localpath = $back_office_dir . $ftype . '/' . $file .'.'. $ftypes{$ftype} .'.'. $date
		    unless $localpath;
		$localpath = $back_office_dir2 . $ftype . '/' . substr($date,0,4) . "/equity/namr/" . $file .'.'. $ftypes{$ftype} .'.'. $date . ".gz"
		    unless -e $localpath;
		$localpath = $localpath . '.gz'
		    if not -e $localpath and -e $localpath . '.gz';

		print "Ftype: $ftype localPath: $localpath\n"
		    if $verbose > 1;
		last if -e $localpath;
		$localpath = undef;
	    }
	} else {
	    $localpath = $back_office_dir . $filetype . '/' . $file .'.'. $ftypes{$filetype} .'.'. $date;
	    print "Path now: $localpath\n"
		if $verbose > 2;
	    $localpath = $localpath . '.gz'
		if not -e $localpath and -e $localpath . '.gz';
	    print "localPath now: $localpath\n"
		if $verbose > 2;

	    # not so easy to construct, need to determine which types
	    $localpath = $back_office_dir2 . $filetype . '/' . substr($date,0,4) . "/equity/$filetype/" . $file .'.'. $ftypes{$filetype} .'.'. $date . ".gz"
		unless -e $localpath;
	    print "Path now: $localpath\n"
		if $verbose;
	    print "$localpath\n"
		if -e $localpath and $verbose > 1;
	}
    }
    unless ( $localpath and -e $localpath ) {
	if ( $path ) {
	    warn "Can't find specified path: $localpath\n";
	} else {
	    warn "Can't find path to file $file ($localpath)\n";
	}
	return 0;
    }

    #warn "Can't find path to file $file ($localpath)\n" and return
	#unless $localpath and -e $localpath;

    my $cmd = ($localpath =~ /.gz$/) ? qq{gunzip -c $localpath|} : $localpath;
    print "CMD: ${cmd}\nLOOKUP[keytype=$keytype]: $lookup\n"
	if $verbose;


    my $state;
    my $fieldcount = 0;
    my %data;

    $fieldnames[$fieldcount++] = "YellowKey";
    if ( $FType eq 'corpact' ) {
	$fieldnames[$fieldcount++] = "ID_BB_COMPANY";
	$fieldnames[$fieldcount++] = "ID_BB_SECURITY";
	$fieldnames[$fieldcount++] = "Status";
	$fieldnames[$fieldcount++] = "ID_SOMETHING";
	$fieldnames[$fieldcount++] = "ActionType";
    } else {
	$fieldnames[$fieldcount++] = "Status";
	$fieldnames[$fieldcount++] = "NumFields";
    }

    open BBDATA, "$cmd" or die "Can't access bb file: $!";
    while (<BBDATA>) {

	chomp;
	next if /^#/ or /^\s*$/;

	/^START-OF-FILE/ && ($state = "START") && next;
	/^START-OF-FIELDS/ && ($state = "FIELDS") && next;
	/^END-OF-FIELDS/ && ($state = "OUT") && next;
	/^START-OF-DATA/ && ($state = "DATA") && next;
	/^END-OF-DATA/ && ($state = "OUT") && next;
	/^END-OF-FILE/ && ($state = "END") && next;

	if ( $state eq "FIELDS" ) {

	    $fieldnames[$fieldcount++] = $_;

	} elsif ( $state eq "DATA" ) {

	    if ( $keyfield == -1 ) {
		# linear lookup (not so bad for this list) or could create a hash and map (later!)
		for ( my $count = 0; $count < scalar @fieldnames; $count++ ) {
		    if ( $fieldnames[$count] eq $keytype ) {
			$keyfield = $count;
		    }
		}
		print "keyfield[$keytype] is $keyfield\n"
		    if $verbose > 2;
	    }

	    my @all_fields = split /\|/;
	    my $key = $all_fields[$keyfield];

	    next unless $key =~ /$lookup/;

	    my %obj;
	    for ( my $count = 0; $count < scalar @all_fields; $count++ ) {

		my $fieldname = $fieldnames[$count];
		$fieldname = "$count" unless $fieldname;

		if ( @fields ) {
		    my $num_match = grep /^$fieldname$/, @fields;
		    #print "$key $fieldname $keytype match=$num_match\n";
		    next if ($num_match==0) and ($fieldname ne $keytype);
		}

		#$data{$key}->{$fieldname} = $all_fields[$count];
		$obj{$fieldname} = $all_fields[$count];
		print "$key $fieldname = $all_fields[$count]\n"
		    if $verbose > 2;
	    }
	    $data{$key} = \%obj;

	    # terminate after an exact match
	    last if $key eq $lookup and $keytype ne "ID_MIC_PRIM_EXCH";
	}
    }

    print "Now doing the lookup\n" if $verbose > 2;
    if ( defined $data{$lookup} ) {
	my $ref = $data{$lookup};
	if ( $display_by_position ) {
	    for ( my $i = 0; $i < $fieldcount; $i++ ) {
		my $field = $fieldnames[$i];
		my $value = $ref->{$field};
		$value = "<EMPTY>"
		    unless defined $value;
		if ( $output_format eq 'XML' ) {
		    print "<field name=\"$field\" value=\"$value\"/>\n";
		} else {
		    print "$field = '$value'\n";
		}
	    }
	} else {
	    # get the fieldnames from the stored object
	    no warnings;
	    foreach my $field ( sort {(($a =~ /(\d+)/)[0] <=> ($b =~ /(\d+)/)[0]) || (uc($a) cmp uc($b))} keys %$ref ) {
		my $value = $ref->{$field};
		if ( $output_format eq 'XML' ) {
		    print "<field name=\"$field\" value=\"$value\"/>\n";
		} else {
		    print "$field = $value\n";
		}
	    }
	    use warnings;
	}
    } else {
	foreach my $key ( keys %data ) {
	    # Look for a match
	    next if $key !~ /$lookup/;
	    my $ref = $data{$key};
	    if ( $display_by_position ) {
		for ( my $i = 0; $i < $fieldcount; $i++ ) {
		    my $field = $fieldnames[$i];
		    my $value = $ref->{$field};
		    $value = '<EMPTY>'
			unless defined $value;
		    if ( $output_format eq 'XML' ) {
			print "<field name=\"$field\" value=\"$value\"/>\n";
		    } else {
			print("$field = '$value'\n")
		    }
		}
	    } else {
		# get the fieldnames from the stored object
		no warnings;
		foreach my $field ( sort {(($a =~ /(\d+)/)[0] <=> ($b =~ /(\d+)/)[0]) || (uc($a) cmp uc($b))} keys %$ref ) {
		    my $value = $ref->{$field};
		    if ( $output_format eq 'XML' ) {
			print "<field name=\"$field\" value=\"$value\"/>\n";
		    } else {
			print "$field = $value\n";
		    }
		}
		use warnings;
	    }
	    print "\n";
	}
    }
}

